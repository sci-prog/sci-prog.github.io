{"version":3,"sources":["webpack:///path---git-intro-90e1d0ec2c49c52a8c0d.js","webpack:///./.cache/json/git-intro.json"],"names":["webpackJsonp","489","module","exports","data","site","siteMetadata","title","siteUrl","authors","name","photo","github","bio","markdownRemark","id","html","frontmatter","date","author","fields","slug","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,8BAAAC,QAAA,6BAAAC,UAAyFC,KAAA,iBAAAC,MAAA,6DAAAC,OAAA,cAAAC,IAAA,mCAA6JH,KAAA,eAAAC,MAAA,6DAAAC,OAAA,cAAAC,IAAA,iCAAwJC,gBAAmBC,GAAA,0HAAAC,KAAA,+wgBAA0hYC,aAAs/IV,MAAA,qBAAAW,KAAA,mBAAAC,OAAA,eAA8EC,QAAWC,KAAA,iBAAuBC,aAAgBD,KAAA","file":"path---git-intro-90e1d0ec2c49c52a8c0d.js","sourcesContent":["webpackJsonp([194907401706789],{\n\n/***/ 489:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Scientific Programming Blog\",\"siteUrl\":\"https://sci-prog.github.io\",\"authors\":[{\"name\":\"Oscar Arbelaez\",\"photo\":\"https://avatars1.githubusercontent.com/u/1621518?s=460&v=4\",\"github\":\"odarbelaeze\",\"bio\":\"Simple programador de Colombia\"},{\"name\":\"Pablo Alcain\",\"photo\":\"https://avatars2.githubusercontent.com/u/6975120?s=400&v=4\",\"github\":\"pabloalcain\",\"bio\":\"Simple físico de Argentina\"}]}},\"markdownRemark\":{\"id\":\"/home/runner/work/sci-prog.github.io/sci-prog.github.io/src/pages/git-intro/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>Una parte fundamental del trabajo de un científico es la comunicación: es importante poder informar a los colegas sobre los resultados de nuestras investigaciones y cómo se obtuvieron, como también cuándo se realizaron ciertos cambios en la metodología.\\nLa comunicación de los resultados es vital, más allá de las herramientas escogidas.\\nPor ejemplo, en el trabajo de un científico experimental es fundamental documentar todos los intentos y las modificaciones que realizó en su experimento antes de obtener resultados, ya que ésta es, al fin y al cabo, la única forma que tiene para luego poder comunicarlos eficientemente: anotarlo en un cuaderno en vez de confiar en la memoria.</p>\\n<p>Para nosotros, los programadores científicos, la realidad es exactamente la misma.\\nSi tenemos un código que funciona y queremos agregarle una nueva característica, lo más probable es que queramos también documentar en qué momento se agregó para ser conscientes de cuál era el estado del programa cuando se obtuvieron los resultados que queremos comunicar.\\nNuevamente, como ya mencionamos, más allá de la herramienta que se utilice, es importante que demos trazabilidad a nuestro trabajo para poder repetirlo e identificar cuándo se pudo haber filtrado un error.\\nLas herramientas disponibles para la trazabilidad y distribución del trabajo conocidas como de Control de Versiones, sí pueden hacer ese trabajo más sencillo.</p>\\n<h1>¿Qué es un Sistema de Control de Versiones?</h1>\\n<p><img src=\\\"/scv_phdcomics-a2ce7d2d2c0d1fdbf36914b844707f1a.gif\\\" alt=\\\"Sistema de Control de Versiones\\\" title=\\\"Not final\\\"></p>\\n<p>Supongamos que estamos desarrollando un programa que resuelve ecuaciones diferenciales numéricamente y que consta de un conjunto de archivos en una carpeta que se llama <code>ODESolver</code>, que originalmente resuelve ecuaciones diferenciales con el método de Euler.\\nEn un momento dado, decidimos que queremos agregar una función para calcular Runge-Kutta de orden 4.\\n¿Cómo lo hacemos?\\nUna alternativa sería modificar directamente la carpeta en la que estamos trabajando, pero… ¿qué pasa si nos equivocamos y rompemos todo el código?\\n¿No nos gustaría poder volver a la versión original de <code>ODESolver</code> que sabíamos que funcionaba?</p>\\n<p>Entonces se nos ocurre una solución: copiamos la carpeta <code>ODESolver</code> a una que se llame <code>ODESolver_nuevo</code> y desarrollamos en esta.\\nSi nos equivocamos y rompemos todo el código, podemos volver a la carpeta original que ya sabíamos que funcionaba.\\nDespués podemos hacer algunas mejoras a este método casero.\\nLa primera puede ser que el nuevo nombre tenga algo relacionado con el desarrollo que hacemos; en el caso del ejemplo, <code>ODESolver_RK4</code>.\\nPero sería aún mejor si llamáramos a la nueva carpeta <code>ODESolver_2</code> y creáramos un archivo de texto llamado, por ejemplo, <code>versiones.txt</code> para registrar los cambios que diga sencillamente:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>1: Método de Euler\\n2: Desarrollo de Runge-Kutta de orden 4</code></pre>\\n      </div>\\n<p>De esta manera, si queremos agregar más cambios sólo tenemos que seguir la numeración secuencial y así podemos leer en el archivo de texto qué agrega cada versión.\\nEs más: cuando alguien quiere saber si la versión que usa tiene o no cierta funcionalidad, busca su versión en el archivo de texto y listo.\\nLo que acabamos de describir es, aunque casero y muy primitivo, un Sistema de Control de Versiones<sup id=\\\"fnref-1\\\"><a href=\\\"#fn-1\\\" class=\\\"footnote-ref\\\">1</a></sup>.\\nLas deficiencias de este SCV son evidentes: ¿qué pasa si, ya en la versión 19 del programa, encontramos un error en una función que existía desde la versión 0?\\nTendríamos que ir versión por versión haciendo esa modificación.\\nPodemos pensar soluciones para este problema, pero todo parece indicar que, ante problemas que siguen creciendo, la única solución es llamar a un <a href=\\\"https://www.youtube.com/watch?v=7mQuHh1X4H4\\\">megazord</a>.\\nHay infinidad de herramientas, con distinto nivel de sofisticación, que permiten controlar las versiones de un software.\\nEn esta entrega (y, me animo a decir, en general en el blog) vamos a hablar de la más extendida de todas: <a href=\\\"https://git-scm.com/\\\"><code>git</code></a>.</p>\\n<h1>Git: Una filosofía de trabajo</h1>\\n<p>La ventaja de usar las herramientas adecuadas para el objetivo que uno quiere lograr (en este caso controlar las versiones) es que, de alguna forma, <em>favorecen</em> (¡o a veces hasta imponen!) una filosofía de trabajo.\\nCon <code>git</code> vamos a lograr hacer de forma sencilla lo antes mencionado con nuestro SCV casero y un par de cosas más:</p>\\n<ol>\\n<li>Hacer backup de estados consistentes del proyecto</li>\\n<li>Documentar cambios</li>\\n<li>Seguir los <em>bugs</em> a través de la historia del desarrollo</li>\\n<li>Compartir cambios</li>\\n<li>Distribuir el desarrollo a muchas personas</li>\\n</ol>\\n<p>Pero para poder entender bien cómo funciona <code>git</code> es necesario primero definir algunos conceptos claves<sup id=\\\"fnref-2\\\"><a href=\\\"#fn-2\\\" class=\\\"footnote-ref\\\">2</a></sup>:</p>\\n<h2>Estados</h2>\\n<p>Los estados son análogos a las carpetas en el ejemplo del SCV casero que hicimos antes.\\nEs importante entender que son algo análogo y no exactamente lo mismo en cuanto a la función que cumplen, veremos más adelante en detalle por qué.\\nCuando terminamos de trabajar en un estado y lo <em>consolidamos</em> (en nuestra analogía, sería decir que terminamos de desarrollar la funcionalidad que queríamos en la carpeta y, entonces, no modificamos más esa carpeta) lo llamamos <em>snapshot</em>.\\nEl <em>snapshot</em> actual se llama <code>HEAD</code>.</p>\\n<h2>Ciclo de vida de los archivos</h2>\\n<p>En un repositorio de git, cada archivo puede tener tres estados:</p>\\n<ol>\\n<li>No-modificado</li>\\n<li>Modificado</li>\\n<li>Actualizado</li>\\n</ol>\\n<p>Un archivo está en estado <code>no-modificado</code> cuando es exactamente igual al archivo que está guardado en el último <em>snapshot</em>.\\nModificar un archivo (por ejemplo, cambiar el nombre de una variable) lo transforma, evidentemente, en un archivo <code>modificado</code>.\\nPero, y esto es <strong>muy importante</strong>, <code>git</code> no <em>hace seguimiento</em> a un\\narchivo sólo porque está en estado <code>modificado</code>.\\nPara que <code>git</code> se <em>haga cargo</em> del archivo <code>modificado</code> lo tenemos que actualizar (o, el término en inglés, <em>stage</em>).\\nCon todos los archivos <code>actualizados</code>, podemos <em>consolidar</em> el cambio y, en consecuencia, tomar un nuevo <em>snapshot</em>.\\nAl hacer esto los archivos que estaban <code>actualizados</code> ahora forman parte del nuevo <em>snapshot</em> que pasa a ser el nuevo <code>HEAD</code> del repositorio.\\nEs decir que consolidar cambios actualiza automáticamente el <code>HEAD</code> del repositorio y de esta manera los archivos que eran <code>actualizados</code> pasan al estado <code>no-modificado</code>.\\nFinalmente, si creamos un archivo nuevo y le queremos hacer seguimiento, tenemos que <em>agregarlo</em> al repositorio.\\nDe la misma manera, podemos <em>remover</em> un archivo del repositorio para dejar de seguirlo.</p>\\n<h1>Repositorios de git: Manos a la obra</h1>\\n<p>Ahora vamos a retomar nuestro proyecto original, <code>ODESolver</code>, pero que desde el comienzo vamos a trabajar dentro de <code>git</code>.\\nEl primer paso es crear el repositorio.\\nPara eso vamos a la carpeta (vacía) en la que queremos iniciar nuestro trabajo y ejecutamos:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ git init .</code></pre>\\n      </div>\\n<p>A partir de este momento, esa carpeta va a ser considerada un repositorio de <code>git</code>.\\nSiempre que queramos saber en qué estado se encuentra el repositorio ejecutamos:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ git status\\nOn branch master\\n\\nInitial commit\\n\\nnothing to commit (create/copy files and use \\\"git add\\\" to track)</code></pre>\\n      </div>\\n<p>En este caso, tanto el repositorio como el directorio están vacíos.\\nAhora creamos el archivo <code>euler.c</code>, que integra una ecuación con el método de Euler.\\nEn el directorio aparece ese archivo, pero <code>git</code> no lo reconoce, pues nunca le dijimos que lo <em>siguiera</em>:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ ls\\neuler.c\\n\\n\\n$ git status\\n\\nOn branch master\\n\\nInitial commit\\n\\nUntracked files:\\n  (use \\\"git add <file>...\\\" to include in what will be committed)\\n\\n    euler.c\\n\\nnothing added to commit but untracked files present (use \\\"git add\\\" to track)</code></pre>\\n      </div>\\n<p>Es decir, <code>euler.c</code> está en el estado <code>modificado</code>.\\nSi agregamos el archivo al repositorio (el comando es <code>git add</code>), pasa a ser <code>actualizado</code>:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ git add euler.c\\n$ git status\\nOn branch master\\n\\nInitial commit\\n\\nChanges to be committed:\\n  (use \\\"git rm --cached <file>...\\\" to unstage)\\n\\n    new file:   euler.c</code></pre>\\n      </div>\\n<p>Ahora <em>consolidamos</em> los archivos actualizados mediante <code>git commit</code>:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ git commit -m \\\"Agregado metodo de Euler\\\"\\n[master (root-commit) 4c4a416] Agregado metodo de Euler\\n 1 file changed, 0 insertions(+), 0 deletions(-)\\n create mode 100644 euler.c</code></pre>\\n      </div>\\n<p>Noten que agregamos un <em>flag</em> <code>-m</code> seguido de una breve explicación de los cambios.\\nEsto es conocido como el <em>mensaje de commit</em>.\\nSi no agregamos el <em>flag</em>, <code>git</code> abre un editor de texto en el que podemos escribir el mensaje.\\n<code>git</code> devuelve en pantalla un pequeño resumen de lo que dijo y un número hexadecimal, llamado <em>commit hash</em> (en este caso <code>4c4a416</code>) que es el que podemos utilizar luego para referirnos a este <em>snapshot</em>.\\nSi ahora preguntamos el estado del repositorio, obtenemos:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ git status\\nOn branch master\\nnothing to commit, working directory clean</code></pre>\\n      </div>\\n<p>Un comentario importante es el mensaje de <em>working directory clean</em>.\\nEso es una forma de decir que no hay archivos en estado <code>modificado</code>, que es de esperar: el archivo <code>euler.c</code> es igual al que está guardado en <code>HEAD</code>.\\nA partir de acá, la tarea para generar un <em>snapshot</em> es siempre la misma:</p>\\n<ol>\\n<li>Modificamos/creamos uno o varios archivos: pasan al <em>working directory</em></li>\\n<li>Los agregamos al <em>staging area</em> con <code>git add</code></li>\\n<li>Los consolidamos en un <em>snapshot</em> con <code>git commit</code></li>\\n</ol>\\n<p>Por ejemplo, ahora desarrollamos Runge-Kutta de orden 4.\\nPara eso creamos y modificamos el archivo <code>rk4.c</code> y:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ git add rk4.c\\n$ git commit -m \\\"Agregado Runge-Kutta de orden 4\\\"\\n[master da5eb82] Agregado Runge-Kutta de orden 4\\n 1 file changed, 0 insertions(+), 0 deletions(-)\\n create mode 100644 rk4.c</code></pre>\\n      </div>\\n<p>Si queremos ver la lista de mensajes de commit, ejecutamos:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ git log\\ncommit da5eb8249b5c9490ac5fa3818ad34ad7453db74e\\nAuthor: Pablo Alcain <pabloalcain@gmail.com>\\nDate:   Sun Jan 21 20:40:14 2018 -0300\\n\\n    Agregado Runge-Kutta de orden 4\\n\\ncommit 4c4a41620df4a19f42ed47e837fc9f8e8f4d7ed1\\nAuthor: Pablo Alcain <pabloalcain@gmail.com>\\nDate:   Sun Jan 21 20:13:57 2018 -0300\\n\\n    Agregado metodo de Euler</code></pre>\\n      </div>\\n<p>y vemos que muestra la historia de todos los <em>snapshots</em> del repositorio.\\nSi queremos ir a un <em>snapshot</em> en particular, es simplemente ejecutar <code>$ git checkout &#x3C;commit hash></code><sup id=\\\"fnref-3\\\"><a href=\\\"#fn-3\\\" class=\\\"footnote-ref\\\">3</a></sup>.\\nEn este caso, para ir al <em>snapshot</em> en el que agregamos el método de Euler:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ git checkout 4c4a\\nNote: checking out '4c4a'.\\n\\nYou are in 'detached HEAD' state. You can look around, make experimental\\nchanges and commit them, and you can discard any commits you make in this\\nstate without impacting any branches by performing another checkout.\\n\\nIf you want to create a new branch to retain commits you create, you may\\ndo so (now or later) by using -b with the checkout command again. Example:\\n\\n  git checkout -b new_branch_name\\n\\nHEAD is now at 4c4a416... Agregado metodo de Euler\\n$ ls\\neuler.c</code></pre>\\n      </div>\\n<p>y observamos que “desapareció”, en el <em>working directory</em>, el archivo <code>rk4.c</code>.\\nEl <code>HEAD</code> dejó de ser <code>da5eb82...</code> y pasó a ser <code>4c4a416...</code>.\\nSi ahora queremos volver al <em>snapshot</em> en el que implementamos Runge-Kutta 4, ejecutamos:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ git checkout da5e\\nPrevious HEAD position was 4c4a416... Agregado metodo de Euler\\nHEAD is now at da5eb82... Agregado Runge-Kutta de orden 4\\n$ ls\\neuler.c  rk4.c</code></pre>\\n      </div>\\n<h1>Algunos comentarios interesantes</h1>\\n<p>Cuando describmos los estados dijimos: “Es importante entender que es algo análogo y no exactamente lo mismo en cuanto a la función que cumplen, vamos a ver más adelante en detalle por qué”.\\nEn general, desarrollar toda una nueva funcionalidad (que sería cuando <em>consolidamos</em> una nueva carpeta en el SCV casero) lleva mucho tiempo, y tiene sentido hacer <em>commits</em> intermedios en los que no terminamos de desarrollar todo pero podemos volver atrás en la historia.\\nEsto jamás se nos habría ocurrido en el SCV casero porque es mucho trabajo <em>consolidar</em> algo: hay que copiar toda la carpeta, editar archivos nuevos, etcétera.\\nPero si en <code>git</code> consolidar es cuestión de unos pocos comandos, ¿por qué no lo aprovechamos?\\nAsí, entonces, tendremos muchos <em>commits</em> que no son interesantes <em>per se</em>.\\n¿Cómo identificamos entonces los <em>commits</em> interesantes, por ejemplo en los que implementamos una nueva funcionalidad?\\nPara resolver esto existen las etiquetas o <em>tags</em>.\\nSi queremos etiquetar un commit específico porque es interesante (en nuestro ejemplo el <code>4c4a16...</code>, que es en el que implementamos Euler, ejecutamos:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ git tag v1.0 4c4a</code></pre>\\n      </div>\\n<p>Y ahora podemos referirnos a ese commit usando el nombre del <em>tag</em>:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ git checkout v1.0</code></pre>\\n      </div>\\n<p>Otro comentario muy relevante es que, a priori, con <code>git</code> podríamos realizar el seguimiento de todo tipo de archivos.\\nSin embargo, y esto es una regla general, los archivos que seguimos son los archivos <em>fuente</em> (por ejemplo el código o algún archivo de configuración), y no los archivos que se generan a través de la compilación o ejecución del programa.</p>\\n<h1>Conclusión</h1>\\n<p>Con realmente <strong>muy</strong> pocos comandos logramos, utilizando <code>git</code>, reproducir el comportamiento del Sistema de Control de Versiones casero que habíamos descrito, pero de forma sencilla y cómoda para el usuario.\\nPero con esto estamos apenas arañando la superficie del verdadero poder de <code>git</code>.\\nTodavía nos quedan descubrir dos aspectos muy importantes: las <em>branches</em> y la distribución de código.\\nEso lo dejamos para una siguiente entrega.</p>\\n<div class=\\\"footnotes\\\">\\n<hr>\\n<ol>\\n<li id=\\\"fn-1\\\">\\n<p>Se puede seguir haciendo mejoras a este sistema casero, pero lo fundamental ya lo hace.</p>\\n<a href=\\\"#fnref-1\\\" class=\\\"footnote-backref\\\">↩</a>\\n</li>\\n<li id=\\\"fn-2\\\">\\n<p>Hay una gran cantidad de conceptos en <code>git</code>, como es de esperar.\\nPero si entendemos estos pocos conceptos en abstracto, es mucho más fácil entender todos los siguientes.</p>\\n<a href=\\\"#fnref-2\\\" class=\\\"footnote-backref\\\">↩</a>\\n</li>\\n<li id=\\\"fn-3\\\">\\n<p>No es necesario escribir el commit hash entero.\\nCon escribir las primeras 4 cifras del número hexadecimal basta para ir hacia ese <em>snapshot</em>.</p>\\n<a href=\\\"#fnref-3\\\" class=\\\"footnote-backref\\\">↩</a>\\n</li>\\n</ol>\\n</div>\",\"frontmatter\":{\"title\":\"Introducción a git\",\"date\":\"January 21, 2018\",\"author\":\"pabloalcain\"},\"fields\":{\"slug\":\"/git-intro/\"}}},\"pathContext\":{\"slug\":\"/git-intro/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---git-intro-90e1d0ec2c49c52a8c0d.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Scientific Programming Blog\",\"siteUrl\":\"https://sci-prog.github.io\",\"authors\":[{\"name\":\"Oscar Arbelaez\",\"photo\":\"https://avatars1.githubusercontent.com/u/1621518?s=460&v=4\",\"github\":\"odarbelaeze\",\"bio\":\"Simple programador de Colombia\"},{\"name\":\"Pablo Alcain\",\"photo\":\"https://avatars2.githubusercontent.com/u/6975120?s=400&v=4\",\"github\":\"pabloalcain\",\"bio\":\"Simple físico de Argentina\"}]}},\"markdownRemark\":{\"id\":\"/home/runner/work/sci-prog.github.io/sci-prog.github.io/src/pages/git-intro/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>Una parte fundamental del trabajo de un científico es la comunicación: es importante poder informar a los colegas sobre los resultados de nuestras investigaciones y cómo se obtuvieron, como también cuándo se realizaron ciertos cambios en la metodología.\\nLa comunicación de los resultados es vital, más allá de las herramientas escogidas.\\nPor ejemplo, en el trabajo de un científico experimental es fundamental documentar todos los intentos y las modificaciones que realizó en su experimento antes de obtener resultados, ya que ésta es, al fin y al cabo, la única forma que tiene para luego poder comunicarlos eficientemente: anotarlo en un cuaderno en vez de confiar en la memoria.</p>\\n<p>Para nosotros, los programadores científicos, la realidad es exactamente la misma.\\nSi tenemos un código que funciona y queremos agregarle una nueva característica, lo más probable es que queramos también documentar en qué momento se agregó para ser conscientes de cuál era el estado del programa cuando se obtuvieron los resultados que queremos comunicar.\\nNuevamente, como ya mencionamos, más allá de la herramienta que se utilice, es importante que demos trazabilidad a nuestro trabajo para poder repetirlo e identificar cuándo se pudo haber filtrado un error.\\nLas herramientas disponibles para la trazabilidad y distribución del trabajo conocidas como de Control de Versiones, sí pueden hacer ese trabajo más sencillo.</p>\\n<h1>¿Qué es un Sistema de Control de Versiones?</h1>\\n<p><img src=\\\"/scv_phdcomics-a2ce7d2d2c0d1fdbf36914b844707f1a.gif\\\" alt=\\\"Sistema de Control de Versiones\\\" title=\\\"Not final\\\"></p>\\n<p>Supongamos que estamos desarrollando un programa que resuelve ecuaciones diferenciales numéricamente y que consta de un conjunto de archivos en una carpeta que se llama <code>ODESolver</code>, que originalmente resuelve ecuaciones diferenciales con el método de Euler.\\nEn un momento dado, decidimos que queremos agregar una función para calcular Runge-Kutta de orden 4.\\n¿Cómo lo hacemos?\\nUna alternativa sería modificar directamente la carpeta en la que estamos trabajando, pero… ¿qué pasa si nos equivocamos y rompemos todo el código?\\n¿No nos gustaría poder volver a la versión original de <code>ODESolver</code> que sabíamos que funcionaba?</p>\\n<p>Entonces se nos ocurre una solución: copiamos la carpeta <code>ODESolver</code> a una que se llame <code>ODESolver_nuevo</code> y desarrollamos en esta.\\nSi nos equivocamos y rompemos todo el código, podemos volver a la carpeta original que ya sabíamos que funcionaba.\\nDespués podemos hacer algunas mejoras a este método casero.\\nLa primera puede ser que el nuevo nombre tenga algo relacionado con el desarrollo que hacemos; en el caso del ejemplo, <code>ODESolver_RK4</code>.\\nPero sería aún mejor si llamáramos a la nueva carpeta <code>ODESolver_2</code> y creáramos un archivo de texto llamado, por ejemplo, <code>versiones.txt</code> para registrar los cambios que diga sencillamente:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>1: Método de Euler\\n2: Desarrollo de Runge-Kutta de orden 4</code></pre>\\n      </div>\\n<p>De esta manera, si queremos agregar más cambios sólo tenemos que seguir la numeración secuencial y así podemos leer en el archivo de texto qué agrega cada versión.\\nEs más: cuando alguien quiere saber si la versión que usa tiene o no cierta funcionalidad, busca su versión en el archivo de texto y listo.\\nLo que acabamos de describir es, aunque casero y muy primitivo, un Sistema de Control de Versiones<sup id=\\\"fnref-1\\\"><a href=\\\"#fn-1\\\" class=\\\"footnote-ref\\\">1</a></sup>.\\nLas deficiencias de este SCV son evidentes: ¿qué pasa si, ya en la versión 19 del programa, encontramos un error en una función que existía desde la versión 0?\\nTendríamos que ir versión por versión haciendo esa modificación.\\nPodemos pensar soluciones para este problema, pero todo parece indicar que, ante problemas que siguen creciendo, la única solución es llamar a un <a href=\\\"https://www.youtube.com/watch?v=7mQuHh1X4H4\\\">megazord</a>.\\nHay infinidad de herramientas, con distinto nivel de sofisticación, que permiten controlar las versiones de un software.\\nEn esta entrega (y, me animo a decir, en general en el blog) vamos a hablar de la más extendida de todas: <a href=\\\"https://git-scm.com/\\\"><code>git</code></a>.</p>\\n<h1>Git: Una filosofía de trabajo</h1>\\n<p>La ventaja de usar las herramientas adecuadas para el objetivo que uno quiere lograr (en este caso controlar las versiones) es que, de alguna forma, <em>favorecen</em> (¡o a veces hasta imponen!) una filosofía de trabajo.\\nCon <code>git</code> vamos a lograr hacer de forma sencilla lo antes mencionado con nuestro SCV casero y un par de cosas más:</p>\\n<ol>\\n<li>Hacer backup de estados consistentes del proyecto</li>\\n<li>Documentar cambios</li>\\n<li>Seguir los <em>bugs</em> a través de la historia del desarrollo</li>\\n<li>Compartir cambios</li>\\n<li>Distribuir el desarrollo a muchas personas</li>\\n</ol>\\n<p>Pero para poder entender bien cómo funciona <code>git</code> es necesario primero definir algunos conceptos claves<sup id=\\\"fnref-2\\\"><a href=\\\"#fn-2\\\" class=\\\"footnote-ref\\\">2</a></sup>:</p>\\n<h2>Estados</h2>\\n<p>Los estados son análogos a las carpetas en el ejemplo del SCV casero que hicimos antes.\\nEs importante entender que son algo análogo y no exactamente lo mismo en cuanto a la función que cumplen, veremos más adelante en detalle por qué.\\nCuando terminamos de trabajar en un estado y lo <em>consolidamos</em> (en nuestra analogía, sería decir que terminamos de desarrollar la funcionalidad que queríamos en la carpeta y, entonces, no modificamos más esa carpeta) lo llamamos <em>snapshot</em>.\\nEl <em>snapshot</em> actual se llama <code>HEAD</code>.</p>\\n<h2>Ciclo de vida de los archivos</h2>\\n<p>En un repositorio de git, cada archivo puede tener tres estados:</p>\\n<ol>\\n<li>No-modificado</li>\\n<li>Modificado</li>\\n<li>Actualizado</li>\\n</ol>\\n<p>Un archivo está en estado <code>no-modificado</code> cuando es exactamente igual al archivo que está guardado en el último <em>snapshot</em>.\\nModificar un archivo (por ejemplo, cambiar el nombre de una variable) lo transforma, evidentemente, en un archivo <code>modificado</code>.\\nPero, y esto es <strong>muy importante</strong>, <code>git</code> no <em>hace seguimiento</em> a un\\narchivo sólo porque está en estado <code>modificado</code>.\\nPara que <code>git</code> se <em>haga cargo</em> del archivo <code>modificado</code> lo tenemos que actualizar (o, el término en inglés, <em>stage</em>).\\nCon todos los archivos <code>actualizados</code>, podemos <em>consolidar</em> el cambio y, en consecuencia, tomar un nuevo <em>snapshot</em>.\\nAl hacer esto los archivos que estaban <code>actualizados</code> ahora forman parte del nuevo <em>snapshot</em> que pasa a ser el nuevo <code>HEAD</code> del repositorio.\\nEs decir que consolidar cambios actualiza automáticamente el <code>HEAD</code> del repositorio y de esta manera los archivos que eran <code>actualizados</code> pasan al estado <code>no-modificado</code>.\\nFinalmente, si creamos un archivo nuevo y le queremos hacer seguimiento, tenemos que <em>agregarlo</em> al repositorio.\\nDe la misma manera, podemos <em>remover</em> un archivo del repositorio para dejar de seguirlo.</p>\\n<h1>Repositorios de git: Manos a la obra</h1>\\n<p>Ahora vamos a retomar nuestro proyecto original, <code>ODESolver</code>, pero que desde el comienzo vamos a trabajar dentro de <code>git</code>.\\nEl primer paso es crear el repositorio.\\nPara eso vamos a la carpeta (vacía) en la que queremos iniciar nuestro trabajo y ejecutamos:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ git init .</code></pre>\\n      </div>\\n<p>A partir de este momento, esa carpeta va a ser considerada un repositorio de <code>git</code>.\\nSiempre que queramos saber en qué estado se encuentra el repositorio ejecutamos:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ git status\\nOn branch master\\n\\nInitial commit\\n\\nnothing to commit (create/copy files and use \\\"git add\\\" to track)</code></pre>\\n      </div>\\n<p>En este caso, tanto el repositorio como el directorio están vacíos.\\nAhora creamos el archivo <code>euler.c</code>, que integra una ecuación con el método de Euler.\\nEn el directorio aparece ese archivo, pero <code>git</code> no lo reconoce, pues nunca le dijimos que lo <em>siguiera</em>:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ ls\\neuler.c\\n\\n\\n$ git status\\n\\nOn branch master\\n\\nInitial commit\\n\\nUntracked files:\\n  (use \\\"git add <file>...\\\" to include in what will be committed)\\n\\n    euler.c\\n\\nnothing added to commit but untracked files present (use \\\"git add\\\" to track)</code></pre>\\n      </div>\\n<p>Es decir, <code>euler.c</code> está en el estado <code>modificado</code>.\\nSi agregamos el archivo al repositorio (el comando es <code>git add</code>), pasa a ser <code>actualizado</code>:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ git add euler.c\\n$ git status\\nOn branch master\\n\\nInitial commit\\n\\nChanges to be committed:\\n  (use \\\"git rm --cached <file>...\\\" to unstage)\\n\\n    new file:   euler.c</code></pre>\\n      </div>\\n<p>Ahora <em>consolidamos</em> los archivos actualizados mediante <code>git commit</code>:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ git commit -m \\\"Agregado metodo de Euler\\\"\\n[master (root-commit) 4c4a416] Agregado metodo de Euler\\n 1 file changed, 0 insertions(+), 0 deletions(-)\\n create mode 100644 euler.c</code></pre>\\n      </div>\\n<p>Noten que agregamos un <em>flag</em> <code>-m</code> seguido de una breve explicación de los cambios.\\nEsto es conocido como el <em>mensaje de commit</em>.\\nSi no agregamos el <em>flag</em>, <code>git</code> abre un editor de texto en el que podemos escribir el mensaje.\\n<code>git</code> devuelve en pantalla un pequeño resumen de lo que dijo y un número hexadecimal, llamado <em>commit hash</em> (en este caso <code>4c4a416</code>) que es el que podemos utilizar luego para referirnos a este <em>snapshot</em>.\\nSi ahora preguntamos el estado del repositorio, obtenemos:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ git status\\nOn branch master\\nnothing to commit, working directory clean</code></pre>\\n      </div>\\n<p>Un comentario importante es el mensaje de <em>working directory clean</em>.\\nEso es una forma de decir que no hay archivos en estado <code>modificado</code>, que es de esperar: el archivo <code>euler.c</code> es igual al que está guardado en <code>HEAD</code>.\\nA partir de acá, la tarea para generar un <em>snapshot</em> es siempre la misma:</p>\\n<ol>\\n<li>Modificamos/creamos uno o varios archivos: pasan al <em>working directory</em></li>\\n<li>Los agregamos al <em>staging area</em> con <code>git add</code></li>\\n<li>Los consolidamos en un <em>snapshot</em> con <code>git commit</code></li>\\n</ol>\\n<p>Por ejemplo, ahora desarrollamos Runge-Kutta de orden 4.\\nPara eso creamos y modificamos el archivo <code>rk4.c</code> y:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ git add rk4.c\\n$ git commit -m \\\"Agregado Runge-Kutta de orden 4\\\"\\n[master da5eb82] Agregado Runge-Kutta de orden 4\\n 1 file changed, 0 insertions(+), 0 deletions(-)\\n create mode 100644 rk4.c</code></pre>\\n      </div>\\n<p>Si queremos ver la lista de mensajes de commit, ejecutamos:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ git log\\ncommit da5eb8249b5c9490ac5fa3818ad34ad7453db74e\\nAuthor: Pablo Alcain <pabloalcain@gmail.com>\\nDate:   Sun Jan 21 20:40:14 2018 -0300\\n\\n    Agregado Runge-Kutta de orden 4\\n\\ncommit 4c4a41620df4a19f42ed47e837fc9f8e8f4d7ed1\\nAuthor: Pablo Alcain <pabloalcain@gmail.com>\\nDate:   Sun Jan 21 20:13:57 2018 -0300\\n\\n    Agregado metodo de Euler</code></pre>\\n      </div>\\n<p>y vemos que muestra la historia de todos los <em>snapshots</em> del repositorio.\\nSi queremos ir a un <em>snapshot</em> en particular, es simplemente ejecutar <code>$ git checkout &#x3C;commit hash></code><sup id=\\\"fnref-3\\\"><a href=\\\"#fn-3\\\" class=\\\"footnote-ref\\\">3</a></sup>.\\nEn este caso, para ir al <em>snapshot</em> en el que agregamos el método de Euler:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ git checkout 4c4a\\nNote: checking out '4c4a'.\\n\\nYou are in 'detached HEAD' state. You can look around, make experimental\\nchanges and commit them, and you can discard any commits you make in this\\nstate without impacting any branches by performing another checkout.\\n\\nIf you want to create a new branch to retain commits you create, you may\\ndo so (now or later) by using -b with the checkout command again. Example:\\n\\n  git checkout -b new_branch_name\\n\\nHEAD is now at 4c4a416... Agregado metodo de Euler\\n$ ls\\neuler.c</code></pre>\\n      </div>\\n<p>y observamos que “desapareció”, en el <em>working directory</em>, el archivo <code>rk4.c</code>.\\nEl <code>HEAD</code> dejó de ser <code>da5eb82...</code> y pasó a ser <code>4c4a416...</code>.\\nSi ahora queremos volver al <em>snapshot</em> en el que implementamos Runge-Kutta 4, ejecutamos:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ git checkout da5e\\nPrevious HEAD position was 4c4a416... Agregado metodo de Euler\\nHEAD is now at da5eb82... Agregado Runge-Kutta de orden 4\\n$ ls\\neuler.c  rk4.c</code></pre>\\n      </div>\\n<h1>Algunos comentarios interesantes</h1>\\n<p>Cuando describmos los estados dijimos: “Es importante entender que es algo análogo y no exactamente lo mismo en cuanto a la función que cumplen, vamos a ver más adelante en detalle por qué”.\\nEn general, desarrollar toda una nueva funcionalidad (que sería cuando <em>consolidamos</em> una nueva carpeta en el SCV casero) lleva mucho tiempo, y tiene sentido hacer <em>commits</em> intermedios en los que no terminamos de desarrollar todo pero podemos volver atrás en la historia.\\nEsto jamás se nos habría ocurrido en el SCV casero porque es mucho trabajo <em>consolidar</em> algo: hay que copiar toda la carpeta, editar archivos nuevos, etcétera.\\nPero si en <code>git</code> consolidar es cuestión de unos pocos comandos, ¿por qué no lo aprovechamos?\\nAsí, entonces, tendremos muchos <em>commits</em> que no son interesantes <em>per se</em>.\\n¿Cómo identificamos entonces los <em>commits</em> interesantes, por ejemplo en los que implementamos una nueva funcionalidad?\\nPara resolver esto existen las etiquetas o <em>tags</em>.\\nSi queremos etiquetar un commit específico porque es interesante (en nuestro ejemplo el <code>4c4a16...</code>, que es en el que implementamos Euler, ejecutamos:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ git tag v1.0 4c4a</code></pre>\\n      </div>\\n<p>Y ahora podemos referirnos a ese commit usando el nombre del <em>tag</em>:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ git checkout v1.0</code></pre>\\n      </div>\\n<p>Otro comentario muy relevante es que, a priori, con <code>git</code> podríamos realizar el seguimiento de todo tipo de archivos.\\nSin embargo, y esto es una regla general, los archivos que seguimos son los archivos <em>fuente</em> (por ejemplo el código o algún archivo de configuración), y no los archivos que se generan a través de la compilación o ejecución del programa.</p>\\n<h1>Conclusión</h1>\\n<p>Con realmente <strong>muy</strong> pocos comandos logramos, utilizando <code>git</code>, reproducir el comportamiento del Sistema de Control de Versiones casero que habíamos descrito, pero de forma sencilla y cómoda para el usuario.\\nPero con esto estamos apenas arañando la superficie del verdadero poder de <code>git</code>.\\nTodavía nos quedan descubrir dos aspectos muy importantes: las <em>branches</em> y la distribución de código.\\nEso lo dejamos para una siguiente entrega.</p>\\n<div class=\\\"footnotes\\\">\\n<hr>\\n<ol>\\n<li id=\\\"fn-1\\\">\\n<p>Se puede seguir haciendo mejoras a este sistema casero, pero lo fundamental ya lo hace.</p>\\n<a href=\\\"#fnref-1\\\" class=\\\"footnote-backref\\\">↩</a>\\n</li>\\n<li id=\\\"fn-2\\\">\\n<p>Hay una gran cantidad de conceptos en <code>git</code>, como es de esperar.\\nPero si entendemos estos pocos conceptos en abstracto, es mucho más fácil entender todos los siguientes.</p>\\n<a href=\\\"#fnref-2\\\" class=\\\"footnote-backref\\\">↩</a>\\n</li>\\n<li id=\\\"fn-3\\\">\\n<p>No es necesario escribir el commit hash entero.\\nCon escribir las primeras 4 cifras del número hexadecimal basta para ir hacia ese <em>snapshot</em>.</p>\\n<a href=\\\"#fnref-3\\\" class=\\\"footnote-backref\\\">↩</a>\\n</li>\\n</ol>\\n</div>\",\"frontmatter\":{\"title\":\"Introducción a git\",\"date\":\"January 21, 2018\",\"author\":\"pabloalcain\"},\"fields\":{\"slug\":\"/git-intro/\"}}},\"pathContext\":{\"slug\":\"/git-intro/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/git-intro.json\n// module id = 489\n// module chunks = 194907401706789"],"sourceRoot":""}