webpackJsonp([1738975126400],{474:function(n,e){n.exports={data:{site:{siteMetadata:{title:"Scientific Programming Blog",author:"Oscar Arbelaez"}},markdownRemark:{id:"/home/travis/build/sci-prog/sci-prog.github.io/src/pages/c-python-i/index.md absPath of file >>> MarkdownRemark",html:'<p>Se habla mucho de Python como un lenguaje para <a href="https://www.google.com.ar/search?q=python+as+a+glue">pegar varios lenguajes distintos</a>.\nA pesar de que muchos usuarios y defensores de Python esgrimen este argumento para valorar Python por sobre otros lenguajes, la realidad es que cualquier lenguaje interpretad (como perl, ruby o el incipiente Julia) es capaz de realizarlo.\nSin embargo, y a pesar del Bloqueo Global del Intérprete (<em>GIL</em> por sus siglas en inglés), el <a href="https://jeffknupp.com/blog/2012/03/31/pythons-hardest-problem/">problema más difícil de Python</a>, Python (especialemte v2.7+) es el lenguaje interpretado principal en aplicaciones científicas, debido sobre todo a la alta disponibilidad de librerías científicas: NumPy, SciPy, SciKitLearn entre otras.\nUna de las ventajas de los lenguajes interpretados por sobre los compilados se vuelve evidente al comparar un código simple para calcular valores medios en Python y C<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup>:</p>\n<h2>Python</h2>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token comment" spellcheck="true"># file: add_numbers.py</span>\ntotal <span class="token operator">=</span> <span class="token number">10000000</span>\n<span class="token keyword">for</span> i <span class="token keyword">in</span> xrange<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>\n  avg <span class="token operator">=</span> <span class="token number">0.0</span>\n  <span class="token keyword">for</span> j <span class="token keyword">in</span> xrange<span class="token punctuation">(</span>total<span class="token punctuation">)</span><span class="token punctuation">:</span>\n    avg <span class="token operator">+=</span> j\n    avg <span class="token operator">=</span> avg<span class="token operator">/</span>total\n<span class="token keyword">print</span> <span class="token string">"Average is {0}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>avg<span class="token punctuation">)</span>\n</code></pre>\n      </div>\n<h2>C</h2>\n<div class="gatsby-highlight">\n      <pre class="language-c"><code><span class="token comment" spellcheck="true">/* file: add_numbers.c */</span>\n<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>\n<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> total<span class="token punctuation">;</span>\n  <span class="token keyword">double</span> avg<span class="token punctuation">;</span>\n  total <span class="token operator">=</span> <span class="token number">10000000</span><span class="token punctuation">;</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    avg <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> total<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      avg <span class="token operator">+</span><span class="token operator">=</span> j<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    avg <span class="token operator">=</span> avg<span class="token operator">/</span>total<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Average is %f\\n"</span><span class="token punctuation">,</span> avg<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>No sólo es la sintaxis de Python mucho más limpia, sino que además tengamos en cuenta que el código de C hay que compilarlo antes de ejecutarlo.\nLa pregunta es, entonces, ¿por qué usamos C?\nLa respuesta es obvia: ambos códigos realizan exactamente lo mismo, pero mientras que el código de Python lleva <code>8.047 s</code><sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup>, el código en C tarda <code>0.284 s</code>: 28 veces más rápido<sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup>.\nEntonces, ¿cómo podemos resolver el problema de la velocidad?\nCualquiera que haya utilizado NumPy sabe que un problema como éste encaja justo en esta librería.\nMiremos cómo quedaría el código de Python utilizando NumPy:</p>\n<h2>Python (with NumPy)</h2>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token comment" spellcheck="true"># file: add_numbers_fast.py</span>\n<span class="token keyword">from</span> numpy <span class="token keyword">import</span> mean<span class="token punctuation">,</span> arange\ntotal <span class="token operator">=</span> <span class="token number">10000000</span>\na <span class="token operator">=</span> arange<span class="token punctuation">(</span>total<span class="token punctuation">)</span>\n<span class="token keyword">for</span> i <span class="token keyword">in</span> xrange<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>\n  avg <span class="token operator">=</span> mean<span class="token punctuation">(</span>a<span class="token punctuation">)</span>\n<span class="token keyword">print</span> <span class="token string">"Average is {0}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>avg<span class="token punctuation">)</span>\n</code></pre>\n      </div>\n<p>Este nuevo código tarda <code>0.266 s</code>, comparable con el de C.\nSin embargo, sabemos que NumPy es bastante estricto: tenemos que usar vectores y escribir nuestra implementación utilizando sólo funciones de NumPy para aprovechar su velocidad.\nEn consecuencia, perdimos la versatilidad de Python.\nLa pregunta es: ¿podemos tener la versatilidad del lenguaje interpretado y la velocidad de uno compilado?\nHay dos formas de hacer esto:</p>\n<ol>\n<li>\n<p><strong>Implementamos un lenguaje interpretado en C:</strong>\nAsí como Python está escrio en C, podemos escribir nuestro propio programa en C y también crear un lenguaje interpretado “alrededor” de nuestro programa principal.\nEl problema principal es que tendríamos que reimplementar muchas cosas en C que no son críticas en tiempo y podría resultar, además, en un lenguaje no muy sólido y con reglas no muy claras.\nUn buen ejemplo de la escritura de un lenguaje interpretado desde cero, con los problemas ya mencionados, a partir de código en C es <a href="http://lammps.sandia.gov/">LAMMPS</a>.</p>\n</li>\n<li>\n<p><strong>Escribimos código en C y en Python por separado y los conectamos:</strong>\nSi todos los lenguajes, en el fondo, tienen que ser código de máquina, entonces <em>tiene que haber</em> una forma de comunicar los lenguajes que queramos entre sí.\nEn este caso, podemos escribir <strong>a)</strong> Código de Python; <strong>b)</strong> Código de C; y <strong>c)</strong> una API C/Python que se encargue de la comunicación.\nSólo escribimos la parte que consume tiempo en C y podemos usar la flexibilidad de Python.\nLa ya mencionada librería NumPy hace esto de hecho para conseguir su gran velocidad<sup id="fnref-4"><a href="#fn-4" class="footnote-ref">4</a></sup>.</p>\n</li>\n</ol>\n<p>Vamos a focalizarnos en las siguientes entregas en la segunda opción.\nPero, a su vez, la API C/Python tiene muchas formas de ser implementada:</p>\n<ol>\n<li>\n<p><strong>Escribimos el módulo completo en C, al estilo de Python:</strong>\nSi Python fue escrito en C, podemos escribir cualquier módulo de Python en C.\nEsto es a través de, por ejemplo, la <a href="https://docs.python.org/2/c-api/">API <code>Python.h</code></a>.\nPersonalmente, he hecho esto un par de veces, y se puede tornar bastante engorroso, ya que hay que escribir mucho del parseo de Python en C (por ejemplo, cómo acceder a los elementos de las listas), y también considerar cuidadosamente el manejo de memoria.\nLa mayor ventaja, sin embargo, es que escribimos el código de C que va a ser ejecutado y, en consecuencia, podemos tomar decisiones de sintonía fina que pueden ser críticas en la velocidad de ejecución.</p>\n</li>\n<li>\n<p><strong>Escribimos en módulo en Python y generamos códico en C a partir de él:</strong> Esto es lo que hace <a href="http://cython.org/">Cython</a>.\nComo se puede ver de los ejemplos en la página oficina, escribimos puro código de Python y luego se convierte a C automáticamente.\nEsta traducción de un lenguaje a otro de similar nivel se conoce como <em>transpilación</em> (yuxtaposición de <em>translation</em> y <em>compilation</em>).\nCython es, efectivamente, un <em>transpilador</em><sup id="fnref-5"><a href="#fn-5" class="footnote-ref">5</a></sup>.\nAunque esto parece muy bueno a priori, la verdad es que, como en cualquier compilador, se requiere muchísimo trabajo en el desarrollo para obtener buenas optimizaciones<sup id="fnref-6"><a href="#fn-6" class="footnote-ref">6</a></sup>.\nLa sintonía fina que antes podíámos hacer con la API C/Python ya no se puede realizar.</p>\n</li>\n<li>\n<p><strong>Escribimos el módulo en C y lo comunicamos explícitamente con Python:</strong>\nSi pudiéramos exponer en Python los tipos de datos de bajo nivel de C (<code>int</code>, <code>float</code>…), podríamos utilizarlos para llamar a librerías de C.\nÉsta es la idea detrás de <a href="https://docs.python.org/2/library/ctypes.html">ctypes</a>.\nEscribimos una función en C como lo haríamos usualmente, pero luego la llamamos <em>desde Python</em> con los tipos de datos adecuados.\nDe esta forma podemos escribir código en C como en el caso <strong>1</strong>, pero con la ventaja de que la interfaz y el manejo de memoria lo hacemos en Python.</p>\n</li>\n</ol>\n<p>Quiero detenerme a discutir brevemente la opción <strong>2</strong>.\nCython y otros parientes cercanos como <a href="http://numba.pydata.org/">Numba</a> pueden resultar en mejoras de tiempo relativamente (¡y a veces sorprendentemente!) buenas con muy poco esfuerzo a partir de código en Python.\nSon, obviamente, la opción a seguir si no supiéramos nada de C.\nO, si el objetivo es que ese código de Python que se arrastra para tardar una hora pase a tardar 10 minutos, seguramente valga la pena intentar este tipo de alternativas.\nPero si escribimos código desde el comienzo mentalizados en el Cómputo de Alto Desempeño, definitivamente no va a alcanzar, justamente porque no podemos hacer optimizaciones “a mano” sobre el código de C, que es generado automáticamente<sup id="fnref-7"><a href="#fn-7" class="footnote-ref">7</a></sup>.</p>\n<p>Las opciones <strong>1</strong> y <strong>3</strong> son muy similares y, en mi opinión, la opción <strong>3</strong> supera en todos los aspectos a la opción <strong>1</strong>.\nEsto es apenas una introducción, y el objetivo es dar una mirada amplia de las posibilidades para llevar a cabo la comunicación entre Python y C.\nEn la segunda entrega vamos a mostrar algunos ejemplos de <strong>ctypes</strong> y su uso básico.\nLa tercera parte la vamos a dedicar a un uso avanzado de <strong>ctypes</strong> que no es discutido usualmente y resulta muy útil para hacer completamente transparente la implementación en C para un eventual usuario de la librería.</p>\n<div class="footnotes">\n<hr>\n<ol>\n<li id="fn-1">\n<p>Nobleza obliga, lo sintético del código no es una ventaja <em>per se</em> de los lenguajes interpretados por sobre los compilados, sino más bien es debido a las características usuales de estos lenguajes.</p>\n<a href="#fnref-1" class="footnote-backref">↩</a>\n</li>\n<li id="fn-2">\n<p>Obviamente todas las medidas de performance son muy dependientes del hardware.</p>\n<a href="#fnref-2" class="footnote-backref">↩</a>\n</li>\n<li id="fn-3">\n<p>Esto significa que una simulación de una hora llevaría un día si usáramos Python.\nSi bien 28x es obviamente una enorme mejora en tiempo, recuerdo haber discutido una vez con un (<em>muy buen</em>) programador, que no trabajaba en HPC, acerca de mejoras de 2x-5x.\nTodavía estoy bastante sorprendido por el hecho de que él no se sorprendía por una mejora de 5x.\nNunca debemos olvidar que, antes de optimizar algo, tenemos que pensar seriamente si vale la pena el esfuerzo.</p>\n<a href="#fnref-3" class="footnote-backref">↩</a>\n</li>\n<li id="fn-4">\n<p>Punto bonus: como estamos ejecutando en realidad una librería, liberamos el Bloque Global del Intérprete y, en la librería, podemos hacer <em>threading</em>.</p>\n<a href="#fnref-4" class="footnote-backref">↩</a>\n</li>\n<li id="fn-5">\n<p>Podríamos discutir si efectivamente es un transpilador o un compilador.\nEs una discusión más profunda respecto de si C y Python son lenguajes del mismo nivel.</p>\n<a href="#fnref-5" class="footnote-backref">↩</a>\n</li>\n<li id="fn-6">\n<p>Lo mismo vale al escribir código en C.\nSin importar cuán bueno sea el compilador, no vamos a obtener mejor rendimiento que con un código bueno, escrito a mano en assembler.</p>\n<a href="#fnref-6" class="footnote-backref">↩</a>\n</li>\n<li id="fn-7">\n<p>Hay una alternativa similar, llamada <a href="http://docs.scipy.org/doc/numpy-dev/f2py/">F2PY</a>, que implementa la misma idea, pero invertida.\nA partir de código de FORTRAN puro, genera automáticamente la interfaz de Python; en consecuencia, tenemos la sintonía fina en el lenguaje compilado y el código generado automáticamente y eventualmente no-optimizado en el ya lento Python (y no crítico en tiempo).</p>\n<a href="#fnref-7" class="footnote-backref">↩</a>\n</li>\n</ol>\n</div>',frontmatter:{title:"Interacción entre C y Python: Parte I",date:"November 19, 2017"}}},pathContext:{slug:"/c-python-i/"}}}});
//# sourceMappingURL=path---c-python-i-cd4ef76f55830f5613fc.js.map