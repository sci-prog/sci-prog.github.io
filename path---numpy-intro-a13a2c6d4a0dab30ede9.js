webpackJsonp([30792937111940],{492:function(n,a){n.exports={data:{site:{siteMetadata:{title:"Scientific Programming Blog",siteUrl:"https://sci-prog.github.io",authors:[{name:"Oscar Arbelaez",photo:"https://avatars1.githubusercontent.com/u/1621518?s=460&v=4",github:"odarbelaeze",bio:"Simple programador de Colombia"},{name:"Pablo Alcain",photo:"https://avatars2.githubusercontent.com/u/6975120?s=400&v=4",github:"pabloalcain",bio:"Simple físico de Argentina"}]}},markdownRemark:{id:"/home/runner/work/sci-prog.github.io/sci-prog.github.io/src/pages/numpy-intro/index.md absPath of file >>> MarkdownRemark",html:'<p>Que Python es demasiado lento es una de las razones para usar cualquier otro\nlenguaje cuando se trata de simulación y manipulación de datos, no obstante\nPython es una herramienta excelente cuando se trata de unir programas escritos\nen otros lenguajes, ejemplo de esto son la librería NumPy y, en general, todas\nlas librerías del ecosistema SciPy. Estas librerías ponen el poder de paquetes\ntradicionales muy fuertes como BLAS y LAPACK al servicio de programas en\nPython, lo que da como resultado un excelente balance entre el rendimiento de\nlos lenguajes de bajo nivel y la usabilidad de Python. En la presente\nintroducción vamos a explorar las capacidades de la estructura de datos básica\nque nos ofrece NumPy: <code>numpy.array</code></p>\n<h2>Tamaño y ejes</h2>\n<p>Para estudiar el tamaño o forma <em>(size or shape)</em> de un arreglo, estudiamos\nalgunas de las funciones que nos ofrece NumPy para la creación de arreglos.\nEmpecemos con la más humilde 😅, construir un arreglo convirtiendo una lista de\nlistas en una matriz:</p>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token keyword">import</span> numpy\nmatrix <span class="token operator">=</span> numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>\n  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n  <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n<span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>matrix<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token comment"># (2,2)</span>\n</code></pre>\n      </div>\n<p>NumPy ofrece herramientas un poco más avanzadas para crear arreglos como:</p>\n<ul>\n<li>Crear un arreglo lleno de unos (<code>1</code>) con un tamaño definido (<code>numpy.ones</code>).</li>\n<li>Crear un arreglo lleno de ceros (<code>0</code>) con un tamaño igual al de otro arreglo\n(<code>numpy.zeros_like</code>).</li>\n<li>Crear un arreglo lleno de números aleatorios con distribución normal con un\ntamaño definido (<code>numpy.random.normal</code>).</li>\n</ul>\n<p>Este es un simple subconjunto de todas las herramientas que ofrece NumPy para\ncrear arreglos, aquí ofrecemos algunos ejemplos.</p>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token keyword">import</span> numpy\nones <span class="token operator">=</span> numpy<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>ones<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token comment"># (10,)</span>\nzeros <span class="token operator">=</span> numpy<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>ones<span class="token punctuation">)</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>zeros<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token comment"># (10,)</span>\nspeed <span class="token operator">=</span> numpy<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>speed<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token comment"># (10,2)</span>\n</code></pre>\n      </div>\n<p>Ahora, el tema que nos atañe es el tamaño o forma y los ejes, pues bien, los\narreglos de NumPy son arreglos <em>n</em>-dimensionales, un arreglo de una dimensión\nes un vector, un arreglo de dos dimensiones es una matriz y un cubo de datos\nsería un arreglo de tres dimensiones, los arreglos <em>n</em>-dimensionales pueden\ntener más dimensiones, pero a partir de tres dimensiones es un poco difícil de\nvisualizar. Ahora el tamaño o forma de un arreglo es la cantidad de elementos\nen cada dimensión, por ejemplo un vector en 3 dimensiones tendrá una forma\n<code>(3,)</code><sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup>, una matriz de 2 por 2 tendrá forma <code>(2,2)</code>, las dimensiones también\nse conocen como ejes, la primera dimensión de una matiz sería <code>axis=0</code>.</p>\n<h2>Operaciones aritméticas</h2>\n<h3>Arreglo con escalar</h3>\n<p>Una vez creados los arreglos estos pueden ser operados con escalares. Siendo\nun arreglo de cualquier forma <code>A</code> y un escalar <code>c</code>, algunas operaciones que\nse pueden realizar con NumPy son:</p>\n<ul>\n<li><code>A + c</code>  suma a cada uno de los elementos del arreglo <code>A</code> la constante <code>c</code>.</li>\n<li><code>A - c</code>, <code>A * c</code>, <code>A / c</code> hacen cada operación con cada uno de los elementos\ndel arreglo <code>A</code>.</li>\n</ul>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token keyword">import</span> numpy\nA <span class="token operator">=</span> numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\nc <span class="token operator">=</span> <span class="token number">1</span>\nD <span class="token operator">=</span> A <span class="token operator">+</span> c <span class="token comment"># [2, 3, 4]</span>\n</code></pre>\n      </div>\n<h3>Arreglos de forma congruente</h3>\n<p>Las operaciones aritméticas entre arreglos de forma congruente son, en general,\nelemento a elemento, si tenemos arreglos de la misma forma <code>A</code> y <code>B</code> se pueden\nefectuar las operaciones <code>A + B</code>, <code>A - B</code>, <code>A * B</code> y <code>A / B</code>,</p>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token keyword">import</span>  numpy\nA <span class="token operator">=</span> numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\nB <span class="token operator">=</span> numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\nC <span class="token operator">=</span> A <span class="token operator">+</span> B <span class="token comment"># [2, 4]</span>\n</code></pre>\n      </div>\n<p>Python recientemente ha introducido un operador para multiplicación de\nmatrices, por ejemplo, si tenemos una matriz <code>A</code> de forma <code>(2, 3)</code> y una matriz\n<code>B</code> de forma <code>(3, 2)</code>, entonces el producto entre matices <code>C</code> se escribiría en\nPython <code>C = A @ B</code> y tendría forma <code>(2, 2)</code> por otra parte otro producto entre\nmatrices <code>D = B @ A</code></p>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token keyword">import</span> numpy\nA <span class="token operator">=</span> numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\nB <span class="token operator">=</span> numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\nC <span class="token operator">=</span> A @ B <span class="token comment"># [[12, 12], [24, 24]]</span>\n</code></pre>\n      </div>\n<h2>Arreglos de forma aparentemente incongruente (<em>Broadcasting</em>)</h2>\n<p>NumPy tiene una característica llamada <em><a href="https://docs.scipy.org/doc/numpy-1.14.0/user/basics.broadcasting.html">broadcasting</a></em>, esta característica\npermite operar sobre arreglos de diferentes forma y número de dimensiones las\nreglas para estas operaciones son bastante simples, sin embargo, debemos tener\nen cuenta que un vector tridimensional tiene forma: <code>(3,)</code> pero también se\npuede ver como una matriz de forma <code>(1,3)</code>, o como un cubo de datos de forma\n<code>(1,1,3)</code>.</p>\n<p>Por medio del <em>broadcasting</em> se pueden realizar operaciones componente a\ncomponente sobre matrices si sus dimensiones, comparadas de la última hacia\natras, cumplen una de las siguientes condiciones:</p>\n<ul>\n<li>Son iguales</li>\n<li>Una de las dos es 1</li>\n</ul>\n<p>En este caso, dos arreglos de formas <code>(3,)</code> y <code>(4,)</code>, no se pueden operar,\nmientras que dos arreglos de la forma <code>(3,)</code> sí se podrán operar (como es de\nesperarse). Pero estas reglas tienen la consecuencia de que dos arreglos de\nformas <code>(3,1)</code> y <code>(4,)</code> sí se pueden operar porque comparando sus formas de\nderecha a izquierda encontramos que:</p>\n<ul>\n<li>1 y 4 no son iguales, pero uno de los dos es igual a 1.</li>\n<li>3 y 1 (la forma <code>(4,)</code> puede ser vista como <code>(1,4)</code>) no son iguales, pero uno\nde los dos es igual a 1.</li>\n</ul>\n<p>Exploremos cómo se pueden realizar estas operaciones cuando las dimensiones no\nson iguales, en este caso, el arreglo cuya dimension es 1 es extendido para\najustarse a la dimensión del otro arreglo, tomemos por ejemplo una matriz de\nceros de forma <code>(3,4)</code> y un vector de forma <code>(4,)</code>:</p>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token keyword">import</span> numpy\nA <span class="token operator">=</span> numpy<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\nB <span class="token operator">=</span> numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>A <span class="token operator">+</span> B<span class="token punctuation">)</span>\n<span class="token comment"># [[1. 2. 3. 4.]</span>\n<span class="token comment">#  [1. 2. 3. 4.]</span>\n<span class="token comment">#  [1. 2. 3. 4.]]</span>\n</code></pre>\n      </div>\n<p>De manera similar funcionaría nuestro ejemplo sobre dos arreglos con formas\n<code>(3,1)</code> y <code>(4,)</code>:</p>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token keyword">import</span> numpy\nA <span class="token operator">=</span> numpy<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\nB <span class="token operator">=</span> numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>A <span class="token operator">+</span> B<span class="token punctuation">)</span>\n<span class="token comment"># [[1. 2. 3. 4.]</span>\n<span class="token comment">#  [1. 2. 3. 4.]</span>\n<span class="token comment">#  [1. 2. 3. 4.]]</span>\n</code></pre>\n      </div>\n<h2>Otras funciones</h2>\n<p>NumPy también ofrece una variedad de funciones especiales que se pueden aplicar\nsobre cada uno de los elementos de un arreglo, por ejemplo:</p>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token keyword">import</span> numpy\nx <span class="token operator">=</span> numpy<span class="token punctuation">.</span>pi <span class="token operator">*</span> numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>numpy<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token comment"># [ 0.0000000e+00  1.0000000e+00  1.2246468e-16 -1.0000000e+00 -2.4492936e-16]</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>numpy<span class="token punctuation">.</span><span class="token builtin">round</span><span class="token punctuation">(</span>numpy<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token comment"># [ 0.  1.  0. -1. -0.]</span>\n</code></pre>\n      </div>\n<p>En el paquete NumPy directamente, se pueden encontrar las funciones matemáticas\nesenciales como <code>numpy.sin</code>, <code>numpy.cos</code>, <code>numpy.sqr</code>, <code>numpy.log</code>, mientras\nque en el paquete SciPy se pueden encontrar funciones especiales como las\nfunciones de Bezel.</p>\n<p>Otras funciones como <code>numpy.sum</code> y <code>numpy.prod</code> calculan la sumatoria o la\nproductoria de una arreglo, estas reciben un eje o una lista de ejes para\ncalcular la reducción a lo largo de ellos. Por ejemplo, para calcular la norma\nde un vector procederíamos:</p>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token keyword">import</span> numpy\nx <span class="token operator">=</span> numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>numpy<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>numpy<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token comment"># 1.7320508075688772</span>\n</code></pre>\n      </div>\n<p>Para esta operación hay un alias, la funcion <code>numpy.linalg.norm</code>. En el paquete\n<code>numpy.linalg</code> se pueden encontrar varias funciones relacionadas con álgebra\nlineal. Para calcular la norma de cada uno de los vectores en una matriz, se\npuede proceder<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup>:</p>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token keyword">import</span> numpy\nr <span class="token operator">=</span> numpy<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>\n<span class="token comment"># [[5 8 9]</span>\n<span class="token comment">#  [0 3 2]</span>\n<span class="token comment">#  [9 4 3]</span>\n<span class="token comment">#  [6 9 8]</span>\n<span class="token comment">#  [7 3 6]]</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>numpy<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>norm<span class="token punctuation">(</span>r<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token comment"># [13.03840481  3.60555128 10.29563014 13.45362405  9.69535971]</span>\n</code></pre>\n      </div>\n<h2>Ejemplo: Velocidad inicial de un sistema de partículas</h2>\n<p>Para calcular la velocidad inicial de un sistema de partículas para una\nsimulación de dinámica molecular se asignan las velocidades como vectores cada\nuno con componentes aleatorias tomadas de una distribución normal. Si se suman\nlos momentos de cada partícula, en este caso, dado que las velocidades se\ntomaron de una distribución aleatoria, el resultado podría ser un valor\ndiferente de cero, el <em>momentum</em> lineal en una simulación de dinámica molecular\nno es deseable así que se debe anular restando la velocidad media de las\npartículas a cada una de las velocidades de las partículas, generemos como\nejemplo este estado inicial:</p>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token keyword">import</span> numpy\n\nn <span class="token operator">=</span> <span class="token number">100</span>   <span class="token comment"># número de partículas</span>\nk <span class="token operator">=</span> <span class="token number">1</span>     <span class="token comment"># factor que escala con la temperatura</span>\n\n<span class="token comment"># usamos una función de creación</span>\nv <span class="token operator">=</span> k <span class="token operator">*</span> numpy<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n\n<span class="token comment"># calculamos la velocidad media de las partículas</span>\n<span class="token comment"># usamos el parámetro axis</span>\nmean_v <span class="token operator">=</span> numpy<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>v<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>mean_v<span class="token punctuation">)</span>\n<span class="token comment"># [-0.04088513  0.01260944  0.05857773]</span>\n\n<span class="token comment"># restamos la media de la velocidad para eliminar el momentum lineal</span>\n<span class="token comment"># aquí usamos broadcasting</span>\nv <span class="token operator">=</span> v <span class="token operator">-</span> mean_v\n<span class="token keyword">print</span><span class="token punctuation">(</span>numpy<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token comment"># [ 7.54951657e-15  4.10782519e-15 -7.77156117e-16]</span>\n<span class="token comment"># aproximadamente [0 0 0], no hay momentum lineal</span>\n</code></pre>\n      </div>\n<p>De esta manera generamos un vector con las velocidades iniciales de una\nsimulación de dinámica molecular usando algunas herramientas básicas de NumPy,\nnotemos que con un poco más de <em>broadcasting</em> se podría eliminar el <em>momentum</em>\nangular para partículas de distintas masas. Notemos también que usando las\nposiciones y algunas líneas de código extra podríamos también eliminar el\n<em>momentum</em> angular.</p>\n<p>Esta entrada presenta solo un pequeño abrebocas de las capacidades de los\narreglos de NumPy, queremos invitar a los lectores a que exploren la\nherramienta, un buen punto de partida es la <a href="https://docs.scipy.org/doc/">documentación</a>. Además, en este\ndocumento nos enfocamos en la ergonomía y la forma de usar NumPy, pero cabe\nresaltar que cada una de las operaciones que se indican a lo largo de este\ndocumento se realizan por medio de librerías de bajo nivel como se indicó en la\nintroducción.</p>\n<div class="footnotes">\n<hr>\n<ol>\n<li id="fn-1">\n<p>La coma después del tamaño de un arreglo unidimensional es necesaria para\nindicar que la forma sigue siendo una tupla.</p>\n<a href="#fnref-1" class="footnote-backref">↩</a>\n</li>\n<li id="fn-2">\n<p>En estos casos usualmente tengo que “adivinar” el parámetro <code>axis</code> que debo\npasar a la funcion en NumPy, espero que sea más o menos claro el parámetro\npara el lector.</p>\n<a href="#fnref-2" class="footnote-backref">↩</a>\n</li>\n</ol>\n</div>',frontmatter:{title:"Introducción a NumPy",date:"May 02, 2018",author:"odarbelaeze"},fields:{slug:"/numpy-intro/"}}},pathContext:{slug:"/numpy-intro/"}}}});
//# sourceMappingURL=path---numpy-intro-a13a2c6d4a0dab30ede9.js.map