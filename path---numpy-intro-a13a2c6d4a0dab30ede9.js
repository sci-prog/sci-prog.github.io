webpackJsonp([30792937111940],{492:function(n,a){n.exports={data:{site:{siteMetadata:{title:"Scientific Programming Blog",siteUrl:"https://sci-prog.github.io",authors:[{name:"Oscar Arbelaez",photo:"https://avatars1.githubusercontent.com/u/1621518?s=460&v=4",github:"odarbelaeze",bio:"Simple programador de Colombia"},{name:"Pablo Alcain",photo:"https://avatars2.githubusercontent.com/u/6975120?s=400&v=4",github:"pabloalcain",bio:"Simple f√≠sico de Argentina"}]}},markdownRemark:{id:"/home/runner/work/sci-prog.github.io/sci-prog.github.io/src/pages/numpy-intro/index.md absPath of file >>> MarkdownRemark",html:'<p>Que Python es demasiado lento es una de las razones para usar cualquier otro\nlenguaje cuando se trata de simulaci√≥n y manipulaci√≥n de datos, no obstante\nPython es una herramienta excelente cuando se trata de unir programas escritos\nen otros lenguajes, ejemplo de esto son la librer√≠a NumPy y, en general, todas\nlas librer√≠as del ecosistema SciPy. Estas librer√≠as ponen el poder de paquetes\ntradicionales muy fuertes como BLAS y LAPACK al servicio de programas en\nPython, lo que da como resultado un excelente balance entre el rendimiento de\nlos lenguajes de bajo nivel y la usabilidad de Python. En la presente\nintroducci√≥n vamos a explorar las capacidades de la estructura de datos b√°sica\nque nos ofrece NumPy: <code>numpy.array</code></p>\n<h2>Tama√±o y ejes</h2>\n<p>Para estudiar el tama√±o o forma <em>(size or shape)</em> de un arreglo, estudiamos\nalgunas de las funciones que nos ofrece NumPy para la creaci√≥n de arreglos.\nEmpecemos con la m√°s humilde üòÖ, construir un arreglo convirtiendo una lista de\nlistas en una matriz:</p>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token keyword">import</span> numpy\nmatrix <span class="token operator">=</span> numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>\n  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n  <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n<span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>matrix<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token comment"># (2,2)</span>\n</code></pre>\n      </div>\n<p>NumPy ofrece herramientas un poco m√°s avanzadas para crear arreglos como:</p>\n<ul>\n<li>Crear un arreglo lleno de unos (<code>1</code>) con un tama√±o definido (<code>numpy.ones</code>).</li>\n<li>Crear un arreglo lleno de ceros (<code>0</code>) con un tama√±o igual al de otro arreglo\n(<code>numpy.zeros_like</code>).</li>\n<li>Crear un arreglo lleno de n√∫meros aleatorios con distribuci√≥n normal con un\ntama√±o definido (<code>numpy.random.normal</code>).</li>\n</ul>\n<p>Este es un simple subconjunto de todas las herramientas que ofrece NumPy para\ncrear arreglos, aqu√≠ ofrecemos algunos ejemplos.</p>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token keyword">import</span> numpy\nones <span class="token operator">=</span> numpy<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>ones<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token comment"># (10,)</span>\nzeros <span class="token operator">=</span> numpy<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>ones<span class="token punctuation">)</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>zeros<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token comment"># (10,)</span>\nspeed <span class="token operator">=</span> numpy<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>speed<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token comment"># (10,2)</span>\n</code></pre>\n      </div>\n<p>Ahora, el tema que nos ata√±e es el tama√±o o forma y los ejes, pues bien, los\narreglos de NumPy son arreglos <em>n</em>-dimensionales, un arreglo de una dimensi√≥n\nes un vector, un arreglo de dos dimensiones es una matriz y un cubo de datos\nser√≠a un arreglo de tres dimensiones, los arreglos <em>n</em>-dimensionales pueden\ntener m√°s dimensiones, pero a partir de tres dimensiones es un poco dif√≠cil de\nvisualizar. Ahora el tama√±o o forma de un arreglo es la cantidad de elementos\nen cada dimensi√≥n, por ejemplo un vector en 3 dimensiones tendr√° una forma\n<code>(3,)</code><sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup>, una matriz de 2 por 2 tendr√° forma <code>(2,2)</code>, las dimensiones tambi√©n\nse conocen como ejes, la primera dimensi√≥n de una matiz ser√≠a <code>axis=0</code>.</p>\n<h2>Operaciones aritm√©ticas</h2>\n<h3>Arreglo con escalar</h3>\n<p>Una vez creados los arreglos estos pueden ser operados con escalares. Siendo\nun arreglo de cualquier forma <code>A</code> y un escalar <code>c</code>, algunas operaciones que\nse pueden realizar con NumPy son:</p>\n<ul>\n<li><code>A + c</code>  suma a cada uno de los elementos del arreglo <code>A</code> la constante <code>c</code>.</li>\n<li><code>A - c</code>, <code>A * c</code>, <code>A / c</code> hacen cada operaci√≥n con cada uno de los elementos\ndel arreglo <code>A</code>.</li>\n</ul>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token keyword">import</span> numpy\nA <span class="token operator">=</span> numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\nc <span class="token operator">=</span> <span class="token number">1</span>\nD <span class="token operator">=</span> A <span class="token operator">+</span> c <span class="token comment"># [2, 3, 4]</span>\n</code></pre>\n      </div>\n<h3>Arreglos de forma congruente</h3>\n<p>Las operaciones aritm√©ticas entre arreglos de forma congruente son, en general,\nelemento a elemento, si tenemos arreglos de la misma forma <code>A</code> y <code>B</code> se pueden\nefectuar las operaciones <code>A + B</code>, <code>A - B</code>, <code>A * B</code> y <code>A / B</code>,</p>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token keyword">import</span>  numpy\nA <span class="token operator">=</span> numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\nB <span class="token operator">=</span> numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\nC <span class="token operator">=</span> A <span class="token operator">+</span> B <span class="token comment"># [2, 4]</span>\n</code></pre>\n      </div>\n<p>Python recientemente ha introducido un operador para multiplicaci√≥n de\nmatrices, por ejemplo, si tenemos una matriz <code>A</code> de forma <code>(2, 3)</code> y una matriz\n<code>B</code> de forma <code>(3, 2)</code>, entonces el producto entre matices <code>C</code> se escribir√≠a en\nPython <code>C = A @ B</code> y tendr√≠a forma <code>(2, 2)</code> por otra parte otro producto entre\nmatrices <code>D = B @ A</code></p>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token keyword">import</span> numpy\nA <span class="token operator">=</span> numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\nB <span class="token operator">=</span> numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\nC <span class="token operator">=</span> A @ B <span class="token comment"># [[12, 12], [24, 24]]</span>\n</code></pre>\n      </div>\n<h2>Arreglos de forma aparentemente incongruente (<em>Broadcasting</em>)</h2>\n<p>NumPy tiene una caracter√≠stica llamada <em><a href="https://docs.scipy.org/doc/numpy-1.14.0/user/basics.broadcasting.html">broadcasting</a></em>, esta caracter√≠stica\npermite operar sobre arreglos de diferentes forma y n√∫mero de dimensiones las\nreglas para estas operaciones son bastante simples, sin embargo, debemos tener\nen cuenta que un vector tridimensional tiene forma: <code>(3,)</code> pero tambi√©n se\npuede ver como una matriz de forma <code>(1,3)</code>, o como un cubo de datos de forma\n<code>(1,1,3)</code>.</p>\n<p>Por medio del <em>broadcasting</em> se pueden realizar operaciones componente a\ncomponente sobre matrices si sus dimensiones, comparadas de la √∫ltima hacia\natras, cumplen una de las siguientes condiciones:</p>\n<ul>\n<li>Son iguales</li>\n<li>Una de las dos es 1</li>\n</ul>\n<p>En este caso, dos arreglos de formas <code>(3,)</code> y <code>(4,)</code>, no se pueden operar,\nmientras que dos arreglos de la forma <code>(3,)</code> s√≠ se podr√°n operar (como es de\nesperarse). Pero estas reglas tienen la consecuencia de que dos arreglos de\nformas <code>(3,1)</code> y <code>(4,)</code> s√≠ se pueden operar porque comparando sus formas de\nderecha a izquierda encontramos que:</p>\n<ul>\n<li>1 y 4 no son iguales, pero uno de los dos es igual a 1.</li>\n<li>3 y 1 (la forma <code>(4,)</code> puede ser vista como <code>(1,4)</code>) no son iguales, pero uno\nde los dos es igual a 1.</li>\n</ul>\n<p>Exploremos c√≥mo se pueden realizar estas operaciones cuando las dimensiones no\nson iguales, en este caso, el arreglo cuya dimension es 1 es extendido para\najustarse a la dimensi√≥n del otro arreglo, tomemos por ejemplo una matriz de\nceros de forma <code>(3,4)</code> y un vector de forma <code>(4,)</code>:</p>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token keyword">import</span> numpy\nA <span class="token operator">=</span> numpy<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\nB <span class="token operator">=</span> numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>A <span class="token operator">+</span> B<span class="token punctuation">)</span>\n<span class="token comment"># [[1. 2. 3. 4.]</span>\n<span class="token comment">#  [1. 2. 3. 4.]</span>\n<span class="token comment">#  [1. 2. 3. 4.]]</span>\n</code></pre>\n      </div>\n<p>De manera similar funcionar√≠a nuestro ejemplo sobre dos arreglos con formas\n<code>(3,1)</code> y <code>(4,)</code>:</p>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token keyword">import</span> numpy\nA <span class="token operator">=</span> numpy<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\nB <span class="token operator">=</span> numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>A <span class="token operator">+</span> B<span class="token punctuation">)</span>\n<span class="token comment"># [[1. 2. 3. 4.]</span>\n<span class="token comment">#  [1. 2. 3. 4.]</span>\n<span class="token comment">#  [1. 2. 3. 4.]]</span>\n</code></pre>\n      </div>\n<h2>Otras funciones</h2>\n<p>NumPy tambi√©n ofrece una variedad de funciones especiales que se pueden aplicar\nsobre cada uno de los elementos de un arreglo, por ejemplo:</p>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token keyword">import</span> numpy\nx <span class="token operator">=</span> numpy<span class="token punctuation">.</span>pi <span class="token operator">*</span> numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>numpy<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token comment"># [ 0.0000000e+00  1.0000000e+00  1.2246468e-16 -1.0000000e+00 -2.4492936e-16]</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>numpy<span class="token punctuation">.</span><span class="token builtin">round</span><span class="token punctuation">(</span>numpy<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token comment"># [ 0.  1.  0. -1. -0.]</span>\n</code></pre>\n      </div>\n<p>En el paquete NumPy directamente, se pueden encontrar las funciones matem√°ticas\nesenciales como <code>numpy.sin</code>, <code>numpy.cos</code>, <code>numpy.sqr</code>, <code>numpy.log</code>, mientras\nque en el paquete SciPy se pueden encontrar funciones especiales como las\nfunciones de Bezel.</p>\n<p>Otras funciones como <code>numpy.sum</code> y <code>numpy.prod</code> calculan la sumatoria o la\nproductoria de una arreglo, estas reciben un eje o una lista de ejes para\ncalcular la reducci√≥n a lo largo de ellos. Por ejemplo, para calcular la norma\nde un vector proceder√≠amos:</p>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token keyword">import</span> numpy\nx <span class="token operator">=</span> numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>numpy<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>numpy<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>x <span class="token operator">*</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token comment"># 1.7320508075688772</span>\n</code></pre>\n      </div>\n<p>Para esta operaci√≥n hay un alias, la funcion <code>numpy.linalg.norm</code>. En el paquete\n<code>numpy.linalg</code> se pueden encontrar varias funciones relacionadas con √°lgebra\nlineal. Para calcular la norma de cada uno de los vectores en una matriz, se\npuede proceder<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup>:</p>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token keyword">import</span> numpy\nr <span class="token operator">=</span> numpy<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>\n<span class="token comment"># [[5 8 9]</span>\n<span class="token comment">#  [0 3 2]</span>\n<span class="token comment">#  [9 4 3]</span>\n<span class="token comment">#  [6 9 8]</span>\n<span class="token comment">#  [7 3 6]]</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>numpy<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>norm<span class="token punctuation">(</span>r<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token comment"># [13.03840481  3.60555128 10.29563014 13.45362405  9.69535971]</span>\n</code></pre>\n      </div>\n<h2>Ejemplo: Velocidad inicial de un sistema de part√≠culas</h2>\n<p>Para calcular la velocidad inicial de un sistema de part√≠culas para una\nsimulaci√≥n de din√°mica molecular se asignan las velocidades como vectores cada\nuno con componentes aleatorias tomadas de una distribuci√≥n normal. Si se suman\nlos momentos de cada part√≠cula, en este caso, dado que las velocidades se\ntomaron de una distribuci√≥n aleatoria, el resultado podr√≠a ser un valor\ndiferente de cero, el <em>momentum</em> lineal en una simulaci√≥n de din√°mica molecular\nno es deseable as√≠ que se debe anular restando la velocidad media de las\npart√≠culas a cada una de las velocidades de las part√≠culas, generemos como\nejemplo este estado inicial:</p>\n<div class="gatsby-highlight">\n      <pre class="language-python"><code><span class="token keyword">import</span> numpy\n\nn <span class="token operator">=</span> <span class="token number">100</span>   <span class="token comment"># n√∫mero de part√≠culas</span>\nk <span class="token operator">=</span> <span class="token number">1</span>     <span class="token comment"># factor que escala con la temperatura</span>\n\n<span class="token comment"># usamos una funci√≥n de creaci√≥n</span>\nv <span class="token operator">=</span> k <span class="token operator">*</span> numpy<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n\n<span class="token comment"># calculamos la velocidad media de las part√≠culas</span>\n<span class="token comment"># usamos el par√°metro axis</span>\nmean_v <span class="token operator">=</span> numpy<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>v<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>\n<span class="token keyword">print</span><span class="token punctuation">(</span>mean_v<span class="token punctuation">)</span>\n<span class="token comment"># [-0.04088513  0.01260944  0.05857773]</span>\n\n<span class="token comment"># restamos la media de la velocidad para eliminar el momentum lineal</span>\n<span class="token comment"># aqu√≠ usamos broadcasting</span>\nv <span class="token operator">=</span> v <span class="token operator">-</span> mean_v\n<span class="token keyword">print</span><span class="token punctuation">(</span>numpy<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token comment"># [ 7.54951657e-15  4.10782519e-15 -7.77156117e-16]</span>\n<span class="token comment"># aproximadamente [0 0 0], no hay momentum lineal</span>\n</code></pre>\n      </div>\n<p>De esta manera generamos un vector con las velocidades iniciales de una\nsimulaci√≥n de din√°mica molecular usando algunas herramientas b√°sicas de NumPy,\nnotemos que con un poco m√°s de <em>broadcasting</em> se podr√≠a eliminar el <em>momentum</em>\nangular para part√≠culas de distintas masas. Notemos tambi√©n que usando las\nposiciones y algunas l√≠neas de c√≥digo extra podr√≠amos tambi√©n eliminar el\n<em>momentum</em> angular.</p>\n<p>Esta entrada presenta solo un peque√±o abrebocas de las capacidades de los\narreglos de NumPy, queremos invitar a los lectores a que exploren la\nherramienta, un buen punto de partida es la <a href="https://docs.scipy.org/doc/">documentaci√≥n</a>. Adem√°s, en este\ndocumento nos enfocamos en la ergonom√≠a y la forma de usar NumPy, pero cabe\nresaltar que cada una de las operaciones que se indican a lo largo de este\ndocumento se realizan por medio de librer√≠as de bajo nivel como se indic√≥ en la\nintroducci√≥n.</p>\n<div class="footnotes">\n<hr>\n<ol>\n<li id="fn-1">\n<p>La coma despu√©s del tama√±o de un arreglo unidimensional es necesaria para\nindicar que la forma sigue siendo una tupla.</p>\n<a href="#fnref-1" class="footnote-backref">‚Ü©</a>\n</li>\n<li id="fn-2">\n<p>En estos casos usualmente tengo que ‚Äúadivinar‚Äù el par√°metro <code>axis</code> que debo\npasar a la funcion en NumPy, espero que sea m√°s o menos claro el par√°metro\npara el lector.</p>\n<a href="#fnref-2" class="footnote-backref">‚Ü©</a>\n</li>\n</ol>\n</div>',frontmatter:{title:"Introducci√≥n a NumPy",date:"May 02, 2018",author:"odarbelaeze"},fields:{slug:"/numpy-intro/"}}},pathContext:{slug:"/numpy-intro/"}}}});
//# sourceMappingURL=path---numpy-intro-a13a2c6d4a0dab30ede9.js.map